<!-- 
SPDX-FileCopyrightText: the TeamDojo authors

SPDX-License-Identifier: Apache-2.0
-->

# ADR-0005: Move Team-Score Calculation to the Backend

| <!-- -->       | <!-- -->                                                                                   |
|----------------|--------------------------------------------------------------------------------------------|
| **Status**:    | ACCEPTED                                                                                   |
| **Date**:      | 2022-10-25                                                                                 |
| **Author(s)**: | Amar Bolkan <amar.bolkan@iteratec.com>, Sven Strittmatter <sven.strittmatter@iteratec.com> |

## Context

TeamDojo has a feature, which tracks a score for each team. Calculation of this score is currently done client side.
To calculate the score for a specific team the following entities are queried from the backend:

- All available _skills_ (`/api/skills`),
- some _team-skills_ (`/api/team-skills`),
- one _team_ (`/api/teams`), and
- all available badges (`api/badges`).

In the dashboard view this leads to all _team-skills_ (possibly #teams * #skills) being loaded into the frontend.

Relevant files for score calculation:

- CompletionCheck `src/main/webapp/app/custom/helper/completion-check.ts`
- RelevanceCheck `src/main/webapp/app/custom/helper/relevance-check.ts`
- TeamScoreCalculation `src/main/webapp/app/custom/helper/team-score-calculation.ts`
- SkillStatusUtils `src/main/webapp/app/custom/helper/skill-status.ts`

Variable used in TeamScore calculation:

- team (containing all achieved skills),
- all available skills, and
- all available badges

### Problem

Depending on the number of _team-skills_ the scores can be incorrect. This happens due to pagination because the
client initially queries only the first page, but the team-score requires all teams to be incorporated into the
calculation. The solution up to this point has been to simply increase the page size. This however is not a long term
solution, especially in terms of scalability as the maximum number of _team-skills_ can increase quite rapidly.

There appear to be two general approaches one of which would be fixing the problem in the frontend and the other to move
the entire calculation into the backend.

### Solution 1: Check if All Pages Have Been Queried in the Frontend

Instead of increasing the maximum amount of entities per page, the client could check if all pages have been queried.
This would ensure that all _team-skills_ have been retrieved from the backend and in turn should lead to all
_team-scores_ being calculated correctly.

### Pros

- Low implementation effort, query for team-skills only needs to be put into a loop.
- No new files need to be added/no custom code needs to be changed or extended.

### Cons

- Keeps the computational load on the client.
- Requires a lot of API calls to retrieve all the data for the calculation.
- _Teams-cores_ can't easily be queried by third party software.
- Might negatively impact scalability of the system, due to increasing amounts of data needing to be queried.

### Solution 2: Moving the Calculation Into the Backend

Create a new backendservice with endpoint to calculate the _team-score_ for a given _team_ and query this from the
frontend. Maybe it makes sense to extend this to an API which calculates the _team-score_ for multiple _teams_ at once.

This solution also comes in some flavours:

#### Persist the _team-Score_ vs. Calculation on Demand

Since the most performance penalty at the moment came from the lot of API calls done by the frontend, we assume that
calculating the data on demand in the backend is sufficient to increase frontend performance. If this is not the case we
can add persistence later.

So, we decided to not persist the data because this would lead into the full-monty of creating and generating code by
Jhipster.

#### Incorporate the _team-Score_ As New Attribute to an Existing Model vs. New Separate Service With API

Incorporate the _team-score_ as new attribute to an existing model forces us to make more custom changes in code
generated by JHipster. This is something we want to avoid because this parts of code must be spotted carefully on every
JHipster upgrade.

So, we decided to implement a whole new API endpoint for this (Controller, DTO, Service, Model, Repository etc.).

Files to be added to the backend:

- API: `CustomTeamScoreResource`,
- data transfer object: `TeamScoreDTO`,
- business logic: `CustomTeamScoreService`,
- domain model: `TeamScore`,
- data layer: `CustomTeamScoreRepository`, and
- of course unit and integration tests.

Files to be changed in the frontend:

- `src/main/webapp/app/custom/overview/teams/overview-teams.component.ts`
- `src/main/webapp/app/custom/teams/teams-status/teams-status.component.ts`

Files to be deleted:

- `src/main/webapp/app/custom/helper/team-score-calculation.ts`

#### Pros

- The new API would allow for third party systems to query the _team-scores_, which would for example enable easy
  monitoring through something like Prometheus.
- Client performance should increase because calculation is now done server side without querying the API multiple
  times.
- Calculating the score on demand avoids having to check after every CRUD operation if the previously calculated score
  is still correct.

#### Cons

- Changes need to be made in client code.
- Custom classes need to be added to the backend. Those might need to be maintained, when updating to new Jhipster
  versions.

## Decision

- We decide to implement Solution 2.
- The score calculations won't be persisted in the database.
- We implement a new API and service.

## Consequences

- Moving the _team-score_ calculation to the backend will shift the computational load to the server. But this should be
  negligible in comparison to the network latency by fetching all the data from the frontend.
- Making _team-scores_ queryable through a separate API enables third party systems to monitor _team-scores_ over time.
- New files need to be added to the backend and client code needs to be adapted.
